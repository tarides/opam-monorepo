<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>manage-duniverse (opam-monorepo.manage-duniverse)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">opam-monorepo</a> &#x00BB; manage-duniverse</nav><header class="odoc-preamble"><h2 id="considerations"><a href="#considerations" class="anchor"></a>Considerations</h2><p>When using opam-monorepo the question arises: how to manage it in comparison to the regular opam workflow? Compared to regular opam usage using opam-monorepo brings lockfiles and a duniverse folder into the repository. There are multiple ways to handle this, with multiple advantages and disadvantages. This document explains the considerations behind dealing with each of those, along with our recommendations.</p><p>The document mentions Git for source control as it currently is the most popular choice, but similar considerations are valid for most other version control systems as well.</p><h2 id="methods"><a href="#methods" class="anchor"></a>Methods</h2><p>We assume the opam file is committed to the repository. Running <code>opam monorepo
lock</code> will create a <code>.locked</code> opam file in addition to the original opam file. Calling <code>opam monorepo pull</code> will create a <code>duniverse</code> folder into which it will unpack the sources of the packages that are mentioned in the lockfile.</p><p>In either case, the regular way of installing dependencies via Opam is not compromised, as the <code>.opam</code> files stay untouched. Only in the case of <code>label-duniverse-in-git</code> <code>dune</code> will prefer the vendored dependencies over the installed ones.</p></header><nav class="odoc-toc"><ul><li><a href="#lockfile-in-git">Lockfile in Git</a><ul><li><a href="#adoption">Adoption</a></li><li><a href="#dealing-with-conflicts">Dealing with conflicts</a></li></ul></li><li><a href="#duniverse-in-git">Duniverse in Git</a><ul><li><a href="#adoption_2">Adoption</a></li><li><a href="#dealing-with-conflicts_2">Dealing with conflicts</a></li></ul></li><li><a href="#unlocked">Not locked</a><ul><li><a href="#adoption_3">Adoption</a></li></ul></li><li><a href="#recommendations">Recommendations</a></li></ul></nav><div class="odoc-content"><h3 id="lockfile-in-git"><a href="#lockfile-in-git" class="anchor"></a>Lockfile in Git</h3><p>This approach is very similar to the regular opam workflow, but in addition to having the <code>.opam</code> file committed to the repository, the lockfile that <code>opam monorepo lock</code> generates is committed as well.</p><p>Advantages include:</p><ul><li>The project repository only grows by one file, thus easy to adopt</li><li>The packages to be installed are reproducible between different machines and contributors</li><li>Easier management of dependencies over dependencies installed in opam switches</li><li>Having the dependencies built by Dune enables additional Dune features like simplified cross-compilation, using a shared Dune cache between projects, etc.</li></ul><p>Disadvantages might be</p><ul><li>Everyone who wants to build the dependencies with Dune needs to have <code>opam-monorepo</code> installed to pull the dependencies first</li><li>Not self-contained - contributors need to <code>pull</code> the sources themselves</li></ul><h4 id="adoption"><a href="#adoption" class="anchor"></a>Adoption</h4><p>To adopt this workflow, the initial lockfiles needs to be created. Because not all packages build with Dune, most likely the <code>opam-overlays</code> repository has to be added initially to supply Dune ports for some packages:</p><pre class="language-ocaml"><code>$ opam repository add dune-universe git+https://github.com/dune-universe/opam-overlays.git</code></pre><p>From here on, a lockfile can be created.</p><pre class="language-ocaml"><code>$ opam monorepo lock</code></pre><p>This creates a <code>.opam.locked</code> file for the project, this has to be added to the repository:</p><pre class="language-ocaml"><code>$ git add *.opam.locked</code></pre><p>As <code>opam monorepo pull</code> creates a <code>duniverse</code> folder with all the sources of the vendored dependencies, it should be excluded by an entry in the <code>.gitignore</code> file:</p><pre class="language-ocaml"><code>duniverse/</code></pre><h4 id="dealing-with-conflicts"><a href="#dealing-with-conflicts" class="anchor"></a>Dealing with conflicts</h4><p>Since multiple contributors can run <code>opam monorepo lock</code> which will produce a different lock file depending on the state of the used OPAM repositories. This might lead to merge conflicts of the lockfiles when merging.</p><p>As such instead of manually trying to resolve all conflicts it is suggested to just fix conflicts in <code>.opam</code> files and regenerate the lock file with <code>opam
monorepo lock</code>, which will produce a new, conflict-free solution.</p><h3 id="duniverse-in-git"><a href="#duniverse-in-git" class="anchor"></a>Duniverse in Git</h3><p>The most extreme approach is to create a lockfile with <code>opam monorepo lock</code>, download all the dependencies via <code>opam monorepo pull</code> and then commit both the lockfile as well as the pulled sources.</p><p>This approach has some advantages:</p><ul><li>Does not require <code>opam</code> to be installed or set-up: only <code>ocaml</code> and <code>dune</code></li><li>Only the person that creates the lockfile and duniverse must have <code>opam-monorepo</code> installed</li><li>The repository can be immediately used after cloning as everything is self-contained</li><li>Easy to modify dependencies if required</li><li>Can be used offline</li></ul><p>Yet unfortunately it also has some disadvantages:</p><ul><li>Can lead to lots of files in repository</li><li>Potentially complicated merge conflicts if multiple contributors update versions of locked packages</li><li>Users might modify the committed sources, yet those patches will be overwritten when <code>opam monorepo pull</code> is run, leading to changes disappearing</li><li>Pulled sources can interact with version control in unexpected ways, see <code>label-git-add</code></li></ul><h4 id="adoption_2"><a href="#adoption_2" class="anchor"></a>Adoption</h4><p>The approach to adopt this workflow is very similar to the others:</p><pre class="language-ocaml"><code>$ opam monorepo lock
$ opam monorepo pull</code></pre><p>When deciding to store the Duniverse in Git, some things need to be kept in mind. Since <code>opam-monorepo</code> unpacks source tarballs, the content of them might interfere with the repository, e.g. by including large files or <code>.gitignore</code> files.</p><p>Thus it is important to force <code>git</code> to include <em>all</em> files that were unpacked by <code>opam-monorepo</code>, i.e. ignoring <code>.gitignore</code> files that might exist in subfolders:</p><pre class="language-ocaml"><code>$ git add *.opam.locked
$ git add -A duniverse/
$ git commit -m &quot;Import duniverse&quot;</code></pre><p>On the other hand, neither the lockfiles nor the duniverse folder should be added to <code>.gitignore</code>, to make sure future updates to the source will be committed as well.</p><h4 id="dealing-with-conflicts_2"><a href="#dealing-with-conflicts_2" class="anchor"></a>Dealing with conflicts</h4><p>Similar as with the lock file in the repository when multiple people update their lock files and pull separately merge conflicts might happen. The easy solution again is not to try to solve the conflict, but instead lock and pull again and replace all conflicting files:</p><pre class="language-ocaml"><code>$ opam monorepo lock
$ git add *.opam.locked
$ opam monorepo pull
$ git add -A duniverse/</code></pre><h3 id="unlocked"><a href="#unlocked" class="anchor"></a>Not locked</h3><p>While this is not a <code>opam-monorepo</code> workflow per se, projects that do not use <code>opam-monorepo</code> can still be used with <code>opam-monorepo</code> and can bring some advantages to the project.</p><p>In this workflow such every contributor is responsible for creating and maintianing their own lockfile and duniverse.</p><p>Advantages include:</p><ul><li>No opt-in to <code>opam-monorepo</code> required, every developer can chose to use it or not</li><li>Easier management of dependencies over dependencies installed in opam switches</li><li>No merge conflicts when multiple collaborators change versions</li><li>Having the dependencies built by Dune makes cross-compilation easier</li></ul><p>If comes however with some caveats:</p><ul><li>Everyone might end up with different packages in their duniverse, thus low reproducability</li><li>Not self-contained</li></ul><h4 id="adoption_3"><a href="#adoption_3" class="anchor"></a>Adoption</h4><p>Using this workflow is very simple</p><pre class="language-ocaml"><code>$ opam monorepo lock
$ opam monorepo pull</code></pre><p>This will lock the versions of packages into a lock file and will download the sources into the <code>duniverse</code> folder. Thus a subsequent <code>dune build</code> will also build the dependencies.</p><p>To make sure the files don't get committed by accident, it is useful to add the following excludes to the <code>.gitignore</code> file:</p><pre class="language-ocaml"><code>*.opam.locked
duniverse/</code></pre><h3 id="recommendations"><a href="#recommendations" class="anchor"></a>Recommendations</h3><p><code>opam-monorepo</code> maintainers encourage the approach of <code>label-lockfile-in-git</code>, since it provides a compromise between reproducibility and changes required to the repository.</p></div></body></html>